---
layout: post
title: "Elixir Phoenix"
date: 2020-05-31
excerpt_separator: <!--more-->
categories: ['Elixir']
---

Phonenix is a webframework. Its job is to act as a web server. Used generally to serve HTML, JSON, websockets.

<!--more-->

## Phoenix commands:
- Generate project:
```
mix phoenix.new discuss
```

- Phoenix uses cowboy as webserver.
- To start phoenix server, run:
```
mix phoenix.server
```

## Server Side Templating vs Single page applicaitons (SPA)

- Phoenix by default support server side templating, however, it has excellent support for SPA as well.

### Server Side Templating:
- User -> HTTP request to server -> Server get a new HTML DOC -> Sends back the rendered page to user
- User always gets a rendered HTML page

### Single Page Application:
- User -> HTTP Request to server -> server sends back HTML page with JS script(React/Angular) -> User -> new request -> HTML page is regenerated by the embedded script


## Phoenix project structure
- Naming is very important aspect in Phoenix. There are certain patterns which you have to follow:
1. In the views directory, the name of .ex file should be "view_name"_view.ex. Example: topic_view.ex. 
This file should contain a module named "view_name"View. example: Discuss.TopicView

2. Then, in the templates directory, there should be a folder with "view_name". In this case, "topic"
3. In the controller directory, there should be file named "view_name"_controller.ex. Example: topic_controller.ex
4. The controller module file should have module named: "view_name"Controller. Example: TopicController (CamelCase)
5. In the model directory, there should be a file name "view_name".ex. This will be the model for the given view

Thus, for a given piece of code, you will have a view, model and controller file.

### web/Templates
- Templates : Elixir template file has extension .eex

#### web/templates/layout
- This directory contain layout HTML files which are essentially the core for your application.
- Layout is collection of html tags which will be command accross all the pages on your website.Example: Header section of html page.

#### web/templates/page
- This directory contains the web pages servers by phoenix. Example, it has index.html.eex

### Controller Directory
- Stored the actual code. This is where the model are referred as well. 

### View and Templates
- contains views and corresponding templates directory.

### Models
- They reside in the models directory
- each model should have schema and changeset

- When we initialize a module with "use :model", then, a struct with schema defined in that model is created by default.

#### Schema
```
  schema "topics:" do
    field :title, :string
  end
```
This tells phoenix the there is topics table and has field title of type string
-
#### Changeset
1. The function is called changeset
2. What it returns is an object also called as changeset
3. The arguments to changeset function are struct and params
4. struct represent record in database or the data to be going into the database rather the schema of the data
5. params represent the values or new data to be added or what you want to update the model with.
6. cast produces changeset to be added. Cast will "cast" the params using struct to produce a changeset.
7. Struct is essentially a structure of database record as per the schema and params is what we want to initialize the struct with.
8. When the module in model is called, it will return an empty strut:

```
iex(1)> struct = %Discuss.Topic{}
%Discuss.Topic{
  __meta__: #Ecto.Schema.Metadata<:built, "topics">,
  id: nil,
  title: nil
}
```

8. validate_required([:title]) ensure the change set contains the :title value.

- This is how to invoke the changeset function:
```
iex(1)> struct = %Discuss.Topic{}
%Discuss.Topic{
  __meta__: #Ecto.Schema.Metadata<:built, "topics">,
  id: nil,
  title: nil
}
iex(2)> params=%{title: "Vins topic"}
%{title: "Vins topic"}
iex(3)> Discuss.Topic.changeset(struct,params)
#Ecto.Changeset<
  action: nil,
  changes: %{title: "Vins topic"},
  errors: [],
  data: #Discuss.Topic<>,
  valid?: true
>
```
9. 

### router.ex
- This contains routing rules. 
-  This file has scope rule. Example, if the path matches "/", and it is a get request, send it to Pagecontroller module, :index function:

```
scope "/", Discuss do
    pipe_through :browser # Use the default browser stack

    get "/", PageController, :index
  end

```

### web.ex
- This file is autogenerated.
- It has below functions:
1. model
2. controller
3. view

When writing a new controller, using use keyword, web file is imported and then either of the three functions referenced. This is how we share the libraries in to the controller.

- This is where you can add a common module that needs to be imported to all the controllers.


## Phoenix MVC Framework
- MVC stands for Model View and Controller. It is an architectural pattern that separates an application into three main logical components: the model, the view and the controller.

- *The Model* : Model corresponds to all data related logic that user works with. This could be data which is transferred between view and controller component or and other data. Example, data stored in database etc.
- *The View* : View corresponds to the UI Logic of the application.  
- *The controller*: Controller is what stiches together view and model.



## Ecto 
- Ecto is open source project
- Ecto is the tool used for data validation and persistence.
- To create a database, run:
```
mix ecto.create
```
This will read the config/dev.exs file and as per the config, create a database in postgres.
- Optionally, you might have to do the following:
vi mix.exs and lock the version of ecto plugin
mix deps.get
mix ecto.create
- Ecto has a repo module which is responsible to insert or apply changeset to database.
- To insert data in to database, use, repo.insert:
```
repo.insert(changeset)
The return value for this is a tuple:
{:ok, post} --> This is for succesfull insert
{:error, changeset} --> This is for failed inserts
```



## Request routing in Phoenix

1. Add a new route in the router.ex. This needs to be added under the scope. Example:

```
get "/topics/new", TopicController, :new
```

2. Now create a file name topic_controller.ex with Discuss.Controller as module.

3. Now add function named new which takes two arguments: conn and params

4. Conn object contains incomping request details such as host, cookies, headers
Sent to Router module (Controlled by router.ex)

5. The modules defines in various controllers then process the conn objects, add/remove things to it .

6. Finally this conn object is sent back to the user.


## Migrations
- Migration file is how you manage databases in phoenix. Ecto is used for this.
- Creating the migration file:

```
mix ecto.gen.migration add_topic
```
- This will create a file which has name as timestamped in the priv/repo/migrations/ directory.
- This file contains set of instructions to create the database tables:
```
defmodule Discuss.Repo.Migrations.AddTopic do
  use Ecto.Migration

  def change do
    create table(:topics) do
      add :title, :string
    end
  end
end
```

- Run the migration:
```
mix ecto.migrate
```

## Phoenix conn and params objects
### conn:
- It is a struct named %Plug.Conn{}
- Its an Elixir struct that represents both incoming and outgoing request for app
- It has keys like host, method, params came with request, route, path info, req_cookies, req_headers
```
body_params: %{},
  cookies: %{},
  halted: false,
  host: "localhost",
  method: "GET",
  owner: #PID<0.616.0>,
  params: %{},
  path_info: ["topics", "new"],
  path_params: %{},
  peer: {{127, 0, 0, 1}, 61841},
  port: 4000,

```

### params:
- This is used to parse a given url. It is a map, example below:

```
%{
  "_csrf_token" => "ASgJbwt9Pms+SAILKClzVQQkZgQGJgAAnaZ6oEOYD/QOrq+fbU1uQg==",
  "_utf8" => "âœ“",
  "topic" => %{"title" => ""}
}
```
- when using the form_for function, all the parameters of form is sent in the params struct to the destination function.  The above example shows how the params looks like when the submit button is clicked.

### Request routing in phoenix:

- User 
    - put in url /topic/new
        - this will go to router.ex match route /topic/new
            - controllers correct controller module and function TopicController :new
                - Controller module name is in format "ResourceController"
                    - Here it get the name of Resource which will be view name, in this case Topic
                        - view by this name should be present in views directory
                            - and template folder by this name should be present in templates directory


### Database handling done by Phoenix:
Controller --> generate Changeset --> send to repo --> Postgresql


### Plugs:
- Its a are functions which do transformations.
- Two type are plug : Module plug and function plugs
- A plug must take a conn and return a conn
- 

## CSS in Phoenix
- CSS in phoenix is stored in static/css folder.
- You can add a new file all add to existing file. It is applied to all html templates.

---

### Forms and templates in elixir
- Elixir provides a special function named form_for to handle HTML forms.
- Consider the following form in EEX template:
```
1 <%= form_for @changeset, topic_path(@conn, :create), fn f -> %>
2  <div class="form-group">
3    <%= text_input f, :title, placeholder: "Title", class: "form-control" %>
4 </div>
5  <%= submit "Save Topic", class: "btn btn-primary" %>
6 <% end %>
```

- Here the code between <%= > brackets encapsulates the elixir code. The above can be converted to following elixir code:
```
 form_for(@changeset, topic_path(@conn, :create), fn f -> end) #This is elixir code for above.
```

- This form is called from the controller module as below:
```
def new(conn, _params) do
    changeset = Topic.changeset(%Topic{}, %{})

    render conn, "new.html", changeset: changeset #this is keywork list You can pass any variable. Example, you can say sum = 1 + 1 and pass sum: sum to template
  end
```
- Whatever is written between <%= and %> is coverted to elixir code by EEX template.
You can say <%= 1 + 1 %> and that will be shown on the html page or put code to do conditional rendering. Example, show a given button based on code.

- Lets decode the above template line by line:

- Line 1: This line can be read as using the form_for function with Changeset is input, whenver user submits the form, send him to topic_path with  conn as attribute and create function using POST.

- When you are calling the render in elixir code, you are passing changeset as variable. This way you can pass any thing to be rendered dynamically to the form.

- Line 3: Here, the form is represented as function f, to which we are adding text_input with title placeholder. This is the anonymous function


- For line one, the topic_path is resoved into the location of the form.
- Lets see what is topic path. Run the following command:
```
mix phoenix.routes

page_path  GET   /            Discuss.PageController :index
topic_path  GET   /topics/new  Discuss.TopicController :new
topic_path  POST  /topics      Discuss.TopicController :create
```
- The first column is general_name of path. It is of the format ControllerName_path.
- The Second and third column tells the URL for the path.
- Thus,topic_path can accept a GET request on /topics/new and it will be redirected to Discuss.TopicController :new
- Hence whenever the user submits the form, he will be sent to route resolved by topic_path(@conn, :create) as below:
    get a reference for topic_path with :create function which will be: /topics with POST. If you go to the router.ex, you will see :
    post "/topics", TopicController, :create

- Instead of writing post /topics, we reference using topic patch and then we can keep changing the urls only at one place which is router.ex






